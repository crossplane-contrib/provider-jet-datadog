/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type DowntimeObservation struct {
	Active *bool `json:"active,omitempty" tf:"active,omitempty"`

	ActiveChildID *float64 `json:"activeChildId,omitempty" tf:"active_child_id,omitempty"`

	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type DowntimeParameters struct {

	// Optionally specify an end date when this downtime should expire
	// +kubebuilder:validation:Optional
	End *float64 `json:"end,omitempty" tf:"end,omitempty"`

	// String representing date and time to end the downtime in RFC3339 format.
	// +kubebuilder:validation:Optional
	EndDate *string `json:"endDate,omitempty" tf:"end_date,omitempty"`

	// An optional message to provide when creating the downtime, can include notification handles
	// +kubebuilder:validation:Optional
	Message *string `json:"message,omitempty" tf:"message,omitempty"`

	// When specified, this downtime will only apply to this monitor
	// +kubebuilder:validation:Optional
	MonitorID *float64 `json:"monitorId,omitempty" tf:"monitor_id,omitempty"`

	// A list of monitor tags (up to 32) to base the scheduled downtime on. Only monitors that have all selected tags are silenced
	// +kubebuilder:validation:Optional
	MonitorTags []*string `json:"monitorTags,omitempty" tf:"monitor_tags,omitempty"`

	// Optional recurring schedule for this downtime
	// +kubebuilder:validation:Optional
	Recurrence []RecurrenceParameters `json:"recurrence,omitempty" tf:"recurrence,omitempty"`

	// specify the group scope to which this downtime applies. For everything use '*'
	// +kubebuilder:validation:Required
	Scope []*string `json:"scope" tf:"scope,omitempty"`

	// Specify when this downtime should start
	// +kubebuilder:validation:Optional
	Start *float64 `json:"start,omitempty" tf:"start,omitempty"`

	// String representing date and time to start the downtime in RFC3339 format.
	// +kubebuilder:validation:Optional
	StartDate *string `json:"startDate,omitempty" tf:"start_date,omitempty"`

	// The timezone for the downtime, default UTC
	// +kubebuilder:validation:Optional
	Timezone *string `json:"timezone,omitempty" tf:"timezone,omitempty"`
}

type RecurrenceObservation struct {
}

type RecurrenceParameters struct {

	// How often to repeat as an integer. For example to repeat every 3 days, select a `type` of `days` and a `period` of `3`.
	// +kubebuilder:validation:Optional
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`

	// The RRULE standard for defining recurring events. For example, to have a recurring event on the first day of each month, use `FREQ=MONTHLY;INTERVAL=1`. Most common rrule options from the iCalendar Spec are supported. Attributes specifying the duration in RRULE are not supported (for example, `DTSTART`, `DTEND`, `DURATION`).
	// +kubebuilder:validation:Optional
	Rrule *string `json:"rrule,omitempty" tf:"rrule,omitempty"`

	// One of `days`, `weeks`, `months`, or `years`
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`

	// The date at which the recurrence should end as a POSIX timestamp. `until_occurrences` and `until_date` are mutually exclusive.
	// +kubebuilder:validation:Optional
	UntilDate *float64 `json:"untilDate,omitempty" tf:"until_date,omitempty"`

	// How many times the downtime will be rescheduled. `until_occurrences` and `until_date` are mutually exclusive.
	// +kubebuilder:validation:Optional
	UntilOccurrences *float64 `json:"untilOccurrences,omitempty" tf:"until_occurrences,omitempty"`

	// A list of week days to repeat on. Choose from: `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`. Only applicable when `type` is `weeks`. First letter must be capitalized.
	// +kubebuilder:validation:Optional
	WeekDays []*string `json:"weekDays,omitempty" tf:"week_days,omitempty"`
}

// DowntimeSpec defines the desired state of Downtime
type DowntimeSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     DowntimeParameters `json:"forProvider"`
}

// DowntimeStatus defines the observed state of Downtime.
type DowntimeStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        DowntimeObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Downtime is the Schema for the Downtimes API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,datadogjet}
type Downtime struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DowntimeSpec   `json:"spec"`
	Status            DowntimeStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// DowntimeList contains a list of Downtimes
type DowntimeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Downtime `json:"items"`
}

// Repository type metadata.
var (
	Downtime_Kind             = "Downtime"
	Downtime_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Downtime_Kind}.String()
	Downtime_KindAPIVersion   = Downtime_Kind + "." + CRDGroupVersion.String()
	Downtime_GroupVersionKind = CRDGroupVersion.WithKind(Downtime_Kind)
)

func init() {
	SchemeBuilder.Register(&Downtime{}, &DowntimeList{})
}
